"""
snaptrade_agent.py
===================

This module provides a thin‑level wrapper around the SnapTrade API to
demonstrate how you might integrate the SnapTrade service into an algorithmic
trading workflow.  It focuses on *account discovery* and *position
retrieval*, leaving order placement functions stubbed out with clear
disclaimers.  **This code is for educational purposes only** and does not
execute any trades.  If you wish to use SnapTrade in production, please
consult the official documentation and ensure you understand the risks
involved in automated trading【22081991962145†screenshot】.

Before you can use this module you must:

* Sign up for a developer account on SnapTrade and obtain your `clientId`
  and `consumerKey`.  These API credentials allow you to make authenticated
  requests to the SnapTrade API.  Your API key consists of two parts: a
  client ID and a consumer key【22081991962145†screenshot】.  Keep the consumer key secret at all times.
* Register one or more **SnapTrade users**.  You create a user by calling
  the `Register user` endpoint with your API key and a unique `userId`.  The
  API returns the `userId` you supplied and a `userSecret` generated by
  SnapTrade【868041246072514†screenshot】.  You will need the user secret in subsequent calls.
* Create a **connection** for each user by generating a SnapTrade connection
  portal URL and having the user authorise access to their brokerage.  When
  the connection flow completes you will have access to the user’s accounts
  through the API【477484261408782†screenshot】.

With a user and active connection in place you can fetch account data.  For
example, you can list the user’s accounts, positions, balances and open
orders.  SnapTrade also exposes endpoints for checking and placing trades,
but these are intentionally omitted here because running automated trades
can lead to financial loss and is beyond the scope of this demonstration.

Example usage:

>>> from snaptrade_agent import SnapTradeClient
>>> client = SnapTradeClient.from_env()
>>> user_id = "my-user-123"
>>> user_secret = os.getenv("SNAPTRADE_USER_SECRET")  # obtained via Register user
>>> accounts = client.list_accounts(user_id, user_secret)
>>> for acct in accounts:
...     positions = client.list_positions(user_id, user_secret, acct["accountId"])
...     print(acct["institution_name"], acct["number"], positions)

Again, **this code does not and will not place trades**.  It is intended to
show how to authenticate and retrieve data using SnapTrade in the context of
building a trading bot.  If you decide to enable trading, thoroughly test in
paper trading mode and consult professional advice.
"""

import os
from typing import Any, Dict, List, Optional

import requests


class SnapTradeClient:
    """A minimal client for interacting with the SnapTrade API.

    Parameters
    ----------
    client_id : str
        Your SnapTrade `clientId`.
    consumer_key : str
        Your SnapTrade `consumerKey`.  Keep this value secret.
    base_url : str, optional
        Base URL for the SnapTrade API.  Defaults to ``"https://api.snaptrade.com/api/v1"``.

    Notes
    -----
    The client only implements a subset of the API for demonstration:

    * ``register_user`` – register a new SnapTrade user and obtain a `userSecret`.
    * ``list_accounts`` – list accounts associated with a user after a connection
      has been established.
    * ``list_positions`` – list positions for a given account.
    * ``list_account_balances`` – list cash balances for a given account.

    Endpoints related to order validation and placement are provided as stubs to
    highlight their existence without implementing them.  Do **not** use
    automated order placement without understanding the risks and the SnapTrade
    terms of service.
    """

    def __init__(self, client_id: str, consumer_key: str, base_url: str = "https://api.snaptrade.com/api/v1") -> None:
        self.client_id = client_id
        self.consumer_key = consumer_key
        self.base_url = base_url.rstrip("/")
        self.session = requests.Session()
        # Include API credentials on every request via headers
        self.session.headers.update({
            "X-Client-Id": self.client_id,
            "X-Consumer-Key": self.consumer_key,
            "Content-Type": "application/json",
        })

    @classmethod
    def from_env(cls) -> "SnapTradeClient":
        """Create a client from environment variables.

        Environment variables used:

        * ``SNAPTRADE_CLIENT_ID``
        * ``SNAPTRADE_CONSUMER_KEY``

        Returns
        -------
        SnapTradeClient
        """
        client_id = os.getenv("SNAPTRADE_CLIENT_ID")
        consumer_key = os.getenv("SNAPTRADE_CONSUMER_KEY")
        if not client_id or not consumer_key:
            raise ValueError("SNAPTRADE_CLIENT_ID and SNAPTRADE_CONSUMER_KEY must be set in environment")
        return cls(client_id, consumer_key)

    def _endpoint(self, path: str) -> str:
        return f"{self.base_url}/{path.lstrip('/')}"

    def register_user(self, user_id: str) -> Dict[str, str]:
        """Register a new SnapTrade user.

        Parameters
        ----------
        user_id : str
            A unique identifier you choose for the user.  SnapTrade will return
            this ID along with a ``userSecret``【868041246072514†screenshot】.

        Returns
        -------
        Dict[str, str]
            A dictionary with keys ``userId`` and ``userSecret``.

        Raises
        ------
        requests.HTTPError
            If the API request fails.
        """
        url = self._endpoint("users")
        payload = {
            "userId": user_id,
        }
        response = self.session.post(url, json=payload)
        response.raise_for_status()
        return response.json()

    def list_accounts(self, user_id: str, user_secret: str) -> List[Dict[str, Any]]:
        """List brokerage accounts for a given user.

        You must have an active connection for the user (i.e., the user
        completed the connection portal flow).  Use the returned account IDs
        when requesting positions or balances【887007288833210†screenshot】.

        Parameters
        ----------
        user_id : str
            The SnapTrade user ID.
        user_secret : str
            The SnapTrade user secret returned when registering the user.

        Returns
        -------
        List[Dict[str, Any]]
            A list of account objects.
        """
        url = self._endpoint(f"users/{user_id}/accounts")
        headers = {
            "X-User-Secret": user_secret,
        }
        response = self.session.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()
        return data if isinstance(data, list) else []

    def list_positions(self, user_id: str, user_secret: str, account_id: str) -> List[Dict[str, Any]]:
        """Retrieve all positions for a specified account.

        Parameters
        ----------
        user_id : str
            The SnapTrade user ID.
        user_secret : str
            The SnapTrade user secret.
        account_id : str
            The account ID returned by :meth:`list_accounts`.

        Returns
        -------
        List[Dict[str, Any]]
            List of position objects (stocks, ETFs, crypto, etc.)【887007288833210†screenshot】.
        """
        url = self._endpoint(f"users/{user_id}/accounts/{account_id}/positions")
        headers = {
            "X-User-Secret": user_secret,
        }
        response = self.session.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()
        return data if isinstance(data, list) else []

    def list_account_balances(self, user_id: str, user_secret: str, account_id: str) -> Dict[str, Any]:
        """Retrieve cash balances for a specified account.

        Parameters
        ----------
        user_id : str
            The SnapTrade user ID.
        user_secret : str
            The SnapTrade user secret.
        account_id : str
            The account ID.

        Returns
        -------
        Dict[str, Any]
            Dictionary containing balance information (e.g. cash available, margin).
        """
        url = self._endpoint(f"users/{user_id}/accounts/{account_id}/balances")
        headers = {
            "X-User-Secret": user_secret,
        }
        response = self.session.get(url, headers=headers)
        response.raise_for_status()
        return response.json()

    # -------------------------------------------------------------------------
    # Order related stubs
    #
    # The methods below illustrate the structure of endpoints used for order
    # validation and placement.  They DO NOT actually execute any trades.
    # If you choose to implement them, do so with extreme caution and only
    # after thorough testing in a paper-trading environment.

    def get_equity_symbol(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Fetch the universal symbol ID for an equity.

        Parameters
        ----------
        symbol : str
            Ticker symbol (e.g. ``"AAPL"``).

        Returns
        -------
        Optional[Dict[str, Any]]
            The first matching symbol object, or ``None`` if not found.
        """
        url = self._endpoint(f"markets/symbols?search={symbol}&type=equity")
        # This endpoint does not require userSecret but may require region
        response = self.session.get(url)
        response.raise_for_status()
        data = response.json()
        if isinstance(data, list) and data:
            return data[0]
        return None

    def check_equity_order(self, user_id: str, user_secret: str, account_id: str, symbol_id: str, quantity: int, side: str, order_type: str = "market") -> Dict[str, Any]:
        """Validate an equity order without executing it.

        This calls the SnapTrade ``Check equity order`` endpoint to estimate
        margin impact and ensure the order can be executed.  It returns a
        ``tradeId`` that can be used to place the order later.  Calling this
        method does **not** place a trade【887007288833210†screenshot】.

        Parameters
        ----------
        user_id : str
            The SnapTrade user ID.
        user_secret : str
            The SnapTrade user secret.
        account_id : str
            Account to trade in.
        symbol_id : str
            Universal symbol ID obtained from :meth:`get_equity_symbol`.
        quantity : int
            Number of shares.
        side : str
            ``"buy"`` or ``"sell"``.
        order_type : str, optional
            Either ``"market"`` or ``"limit"``.

        Returns
        -------
        Dict[str, Any]
            Response from the SnapTrade API, including a ``tradeId``.
        """
        url = self._endpoint(f"users/{user_id}/accounts/{account_id}/orders/check")
        headers = {"X-User-Secret": user_secret}
        payload = {
            "symbolId": symbol_id,
            "orderType": order_type,
            "side": side,
            "quantity": quantity,
        }
        response = self.session.post(url, json=payload, headers=headers)
        response.raise_for_status()
        return response.json()

    def place_order(self, user_id: str, user_secret: str, account_id: str, trade_id: str) -> Dict[str, Any]:
        """Place a previously checked order (stub).

        **WARNING:** This method illustrates how one would call the SnapTrade
        ``Place order`` endpoint.  It does **not** execute a trade in this
        demonstration because automated order placement is outside the scope of
        this agent and may not be permitted by policy.  Use with caution.

        Parameters
        ----------
        user_id : str
            The SnapTrade user ID.
        user_secret : str
            The SnapTrade user secret.
        account_id : str
            Account to trade in.
        trade_id : str
            Trade ID returned by :meth:`check_equity_order`.

        Returns
        -------
        Dict[str, Any]
            Response from the SnapTrade API if trade placement were allowed.
        """
        raise NotImplementedError("Automated order placement is disabled in this demonstration.  Review policies before enabling.")


def demo_list_positions() -> None:
    """Demonstrate retrieving account positions using environment variables.

    Set the following environment variables before running this function:

    * ``SNAPTRADE_CLIENT_ID``
    * ``SNAPTRADE_CONSUMER_KEY``
    * ``SNAPTRADE_USER_ID``
    * ``SNAPTRADE_USER_SECRET``

    This function will list all accounts and positions for the user.  It does
    not execute trades.
    """
    user_id = os.getenv("SNAPTRADE_USER_ID")
    user_secret = os.getenv("SNAPTRADE_USER_SECRET")
    if not user_id or not user_secret:
        raise RuntimeError("SNAPTRADE_USER_ID and SNAPTRADE_USER_SECRET must be set to run the demo.")
    client = SnapTradeClient.from_env()
    accounts = client.list_accounts(user_id, user_secret)
    for acct in accounts:
        acct_id = acct.get("accountId")
        print(f"Account {acct_id} ({acct.get('institution_name')} {acct.get('number')})")
        positions = client.list_positions(user_id, user_secret, acct_id)
        for pos in positions:
            symbol = pos.get("symbol")
            qty = pos.get("quantity")
            print(f"  {symbol}: {qty}")


if __name__ == "__main__":  # pragma: no cover
    demo_list_positions()
